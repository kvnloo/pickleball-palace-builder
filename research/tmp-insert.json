{"name":"Zustand Transient Updates Pattern","category":"state","description":"Bypass React re-renders for high-frequency state changes by using useRef + store.subscribe() instead of useStore selector hooks. Pattern: (1) Read initial state into useRef, (2) In useEffect, subscribe to store changes and update ref.current, (3) In useFrame, read from ref.current instead of React state. This is officially recommended by Zustand for R3F game development. The subscribe callback runs synchronously outside React scheduler. Combined with Zustand getState().mutateDirectly() for writes, this creates a fully synchronous read/write path that never triggers React reconciliation. For game state specifically: store.getState() in useFrame reads current state, direct mutation of the game object avoids Map cloning, and subscribe() notifies only the refs that need updating. Zustand explicitly documents this as the transient updates pattern.","applicability_score":9.0,"performance_gain_estimate":"Eliminate React re-render overhead (1-5ms per frame) for game state updates","implementation_notes":"In GameSession component: const gameRef = useRef(useGameStore.getState().games.get(courtId)); useEffect(() => useGameStore.subscribe(s => { gameRef.current = s.games.get(courtId); }), [courtId]); useFrame((_, delta) => { const game = gameRef.current; if (!game) return; // directly mutate game fields, update Three.js refs }). For writes: useGameStore.getState().updateGame(courtId, delta) but internally updateGame should mutate in place rather than creating new Map. Key insight: Zustand set() is only needed when React UI needs to update (scores displayed in HTML overlay). For 60fps physics, bypass set() entirely.","browser_support":"All","risks":"Bypasses React concurrent mode. Stale ref values possible if not subscribed correctly. Must be careful about component unmount cleanup to avoid memory leaks from dangling subscriptions.","dependencies":"zustand"}