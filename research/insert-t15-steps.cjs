const Database = require('better-sqlite3');
const path = require('path');
const db = new Database(path.join(__dirname, 'performance-kb.db'));
db.pragma('journal_mode = WAL');

const ITER_ID = 12;

const steps = [
  // === L1 Steps (Module/Function Level) ===
  {
    iteration_id: ITER_ID,
    resolution: 'L1',
    sequence_number: 1,
    title: 'ELIMINATE: calculateShotVelocity Return Allocation',
    description: 'calculateShotVelocity() (gameStore.ts:88-110) returns a new {x,y,z} object every call. Called on every serve and rally hit (multiple times per frame with multiple courts). SOLUTION: Write directly into pre-allocated tempVec (already exists at line 6!) then copy fields into ball.velocity.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'MAKER=Eliminate. tempVec already exists but is unused. The function returns new object literals on every shot. Reuse tempVec as output parameter.',
    implementation_approach: '1. Change calculateShotVelocity to write into a passed output object instead of returning new one. 2. Signature: calculateShotVelocityInto(fromX, fromZ, toX, toZ, shotType, out). 3. Callers pass ball.velocity directly as output. 4. Remove all {x:,y:,z:} wrapper objects.',
    estimated_effort: '30m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '88-110,184-188,249-253',
    code_snippet: 'BEFORE: function calculateShotVelocity(from,to,shot){return{x:...,y:...,z:...}}; ball.velocity=calculateShotVelocity({x:bx,z:bz},{x:tx,z:tz},serve). AFTER: function calculateShotVelocityInto(fromX,fromZ,toX,toZ,shot,out){out.x=...;out.y=...;out.z=...}; calculateShotVelocityInto(bx,bz,tx,tz,serve,ball.velocity);',
    status: 'pending',
    confidence_score: 0.97,
    metadata: JSON.stringify({maker_action:'eliminate',allocation_items:[9],bytes_saved_per_hit:48,fps_impact:5}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L1',
    sequence_number: 2,
    title: 'ELIMINATE: ball.position Object Creation on Serve/Wait',
    description: 'Lines 135 and 161 create new position objects: ball.position = { x: serverPos.x, y: 1.0, z: serverPos.z }. SOLUTION: Mutate existing position fields in place.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'MAKER=Eliminate. ball.position is already an object with x,y,z fields. No need to replace it; mutate fields directly.',
    implementation_approach: 'Replace ball.position = { x:a, y:b, z:c } with ball.position.x=a; ball.position.y=b; ball.position.z=c;',
    estimated_effort: '10m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '135,161',
    code_snippet: 'BEFORE: ball.position = { x: serverPos.x, y: 1.0, z: serverPos.z }; AFTER: ball.position.x = serverPos.x; ball.position.y = 1.0; ball.position.z = serverPos.z;',
    status: 'pending',
    confidence_score: 0.99,
    metadata: JSON.stringify({maker_action:'eliminate',allocation_items:[8],bytes_saved_per_serve:48}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L1',
    sequence_number: 3,
    title: 'ELIMINATE: players.find() Iterator in Rally Hit',
    description: 'Line 245: players.find(p => p.team === targetTeam) creates an iterator and a closure. Called during rally hits. SOLUTION: Use direct index calculation.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'MAKER=Eliminate. Team membership is static (players 0,1 = A; 2,3 = B). Use direct index instead of .find().',
    implementation_approach: 'Replace players.find(p => p.team === targetTeam) with: const targetIdx = targetTeam === "A" ? 2 : 0; const targetPlayer = players[targetIdx];',
    estimated_effort: '10m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '244-245',
    code_snippet: 'BEFORE: const targetPlayer = players.find(p => p.team === targetTeam) || players[0]; AFTER: const targetIdx = targetTeam === "A" ? 2 : 0; const targetPlayer = players[targetIdx];',
    status: 'pending',
    confidence_score: 0.99,
    metadata: JSON.stringify({maker_action:'eliminate',allocation_items:[4],bytes_saved_per_hit:64}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L1',
    sequence_number: 4,
    title: 'ELIMINATE: Temporary Object Args to calculateShotVelocity',
    description: 'Lines 184-186 and 249-251: {x: ball.position.x, z: ball.position.z} and {x: targetX, z: targetZ} create two temporary objects per shot. SOLUTION: Co-solved by L1-step-1 which changes signature to scalar parameters.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'MAKER=Eliminate. Co-solved with L1-1 by changing to scalar parameters (fromX, fromZ, toX, toZ).',
    implementation_approach: 'Included in L1-step-1 implementation. The new signature calculateShotVelocityInto(fromX,fromZ,toX,toZ,shot,out) eliminates both wrapper objects.',
    estimated_effort: '0m',
    dependencies: 'L1-step-1',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '184-186,249-251',
    code_snippet: 'ELIMINATED: {x: ball.position.x, z: ball.position.z} wrapper objects removed by scalar params',
    status: 'pending',
    confidence_score: 0.99,
    metadata: JSON.stringify({maker_action:'eliminate',allocation_items:[8,9],bytes_saved_per_hit:96}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L1',
    sequence_number: 5,
    title: 'ELIMINATE: initializeGame set() Map Clone',
    description: 'Lines 138-142: initializeGame uses set(state => { const newGames = new Map(state.games); ... }). Not hot-path but should use consistent direct mutation pattern.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'MAKER=Alter. Not hot-path but aligns with zero-alloc pattern established in L0-1.',
    implementation_approach: 'get().games.set(courtId, game); set(s => ({_gameVersion: (s._gameVersion||0)+1}));',
    estimated_effort: '10m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '138-142',
    code_snippet: 'BEFORE: set(state => { const newGames = new Map(state.games); newGames.set(courtId,game); return {games:newGames}; }); AFTER: get().games.set(courtId,game); set(s=>({_gameVersion:(s._gameVersion||0)+1}));',
    status: 'pending',
    confidence_score: 0.92,
    metadata: JSON.stringify({maker_action:'alter',allocation_items:[1],consistency:true}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L1',
    sequence_number: 6,
    title: 'ELIMINATE: endGame set() Map Clone',
    description: 'Lines 314-318: endGame uses same Map clone pattern. Apply consistent mutation pattern.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'MAKER=Alter. Consistency with zero-alloc pattern.',
    implementation_approach: 'get().games.delete(courtId); set(s => ({_gameVersion: (s._gameVersion||0)+1}));',
    estimated_effort: '5m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '314-318',
    code_snippet: 'BEFORE: set(state=>{const newGames=new Map(state.games); newGames.delete(courtId); return {games:newGames};}); AFTER: get().games.delete(courtId); set(s=>({_gameVersion:(s._gameVersion||0)+1}));',
    status: 'pending',
    confidence_score: 0.92,
    metadata: JSON.stringify({maker_action:'alter',allocation_items:[1]}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L1',
    sequence_number: 7,
    title: 'ELIMINATE: useRobotController Object Literal Fallback in useFrame',
    description: 'useRobotController.ts line 100-104: const state = robotStates.current.get(robot.id) || { currentPath: [], cleaningPath: [], rotation: 0 }; creates a fallback object EVERY FRAME for every robot that has no state yet. SOLUTION: Initialize state in Map when first seen.',
    related_files: 'src/hooks/useRobotController.ts',
    rationale: 'MAKER=Eliminate. The fallback object literal allocates two arrays and an object every frame per robot without existing state.',
    implementation_approach: '1. In useFrame, check if state exists; if not, create and store once. 2. On subsequent frames, the stored state is reused with zero allocation.',
    estimated_effort: '15m',
    target_file: 'src/hooks/useRobotController.ts',
    target_lines: '100-104',
    code_snippet: 'BEFORE: const state = robotStates.current.get(robot.id) || {currentPath:[],cleaningPath:[],rotation:0}; AFTER: let state=robotStates.current.get(robot.id); if(!state){state={currentPath:[],cleaningPath:[],rotation:0};robotStates.current.set(robot.id,state);}',
    status: 'pending',
    confidence_score: 0.95,
    metadata: JSON.stringify({maker_action:'eliminate',bytes_saved_per_frame:128}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L1',
    sequence_number: 8,
    title: 'ELIMINATE: useRobotController Object Spread in State Updates',
    description: 'useRobotController.ts lines 113-117, 126-130, 182-186: {...state, ...} creates new objects via spread. SOLUTION: Mutate state properties directly (robotStates is a useRef Map, already mutable).',
    related_files: 'src/hooks/useRobotController.ts',
    rationale: 'MAKER=Eliminate. robotStates is ref-held Map, not Zustand state. Entries can be mutated directly.',
    implementation_approach: 'Replace robotStates.current.set(id, {...state, currentPath: path}) with state.currentPath = path; state.cleaningPath = cp;',
    estimated_effort: '15m',
    target_file: 'src/hooks/useRobotController.ts',
    target_lines: '113-117,126-130,182-186',
    code_snippet: 'BEFORE: robotStates.current.set(robot.id,{...state,currentPath:[],cleaningPath:path}); AFTER: state.currentPath=[]; state.cleaningPath=path;',
    status: 'pending',
    confidence_score: 0.95,
    metadata: JSON.stringify({maker_action:'eliminate',bytes_saved_per_frame:192}),
  },

  // === L2 Steps (Line-Level Implementation Details) ===
  {
    iteration_id: ITER_ID,
    resolution: 'L2',
    sequence_number: 1,
    title: 'L2: gameStore.ts - Remove per-frame set() and add _gameVersion',
    description: 'Exact implementation for L0-1. Add _gameVersion field, capture prevStatus/prevScore before switch, compare after, only call set() on change.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'L2 detail of L0-1',
    implementation_approach: 'interface GameStore { ... _gameVersion: number; } ... updateGame: (courtId, dt) => { const game = get().games.get(courtId); if(!game) return; const prevStatus=game.status; const prevA=game.teamAScore; const prevB=game.teamBScore; /* existing switch mutates game in place */ if(game.status!==prevStatus||game.teamAScore!==prevA||game.teamBScore!==prevB){ set(s=>({_gameVersion:s._gameVersion+1})); } }',
    estimated_effort: '30m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '8-16,145-311',
    exact_instructions: 'Step 1: Add _gameVersion: number to GameStore interface. Step 2: Initialize _gameVersion: 0 in create. Step 3: In updateGame, before switch: const prevStatus=game.status; const prevA=game.teamAScore; const prevB=game.teamBScore; Step 4: After switch (line 303), replace lines 306-310 with: if(game.status!==prevStatus||game.teamAScore!==prevA||game.teamBScore!==prevB){set(s=>({_gameVersion:s._gameVersion+1}));}',
    status: 'pending',
    confidence_score: 0.95,
    metadata: JSON.stringify({parent_step:'L0-1'}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L2',
    sequence_number: 2,
    title: 'L2: gameStore.ts - Rewrite calculateShotVelocity as output-param',
    description: 'Exact implementation for L1-1. Change function signature, write into output object, update all call sites.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'L2 detail of L1-1',
    exact_instructions: 'Step 1: Rename function to calculateShotVelocityInto(fromX: number, fromZ: number, toX: number, toZ: number, shotType: ShotType, out: {x:number,y:number,z:number}): void. Step 2: Replace return {...} with: out.x = (dx/totalTime)*variance; out.y = Math.sqrt(2*Math.abs(GRAVITY)*config.arcHeight); out.z = (dz/totalTime)*variance; Step 3: At line 184-188, replace ball.velocity = calculateShotVelocity({x:...,z:...},{x:...,z:...},"serve") with calculateShotVelocityInto(ball.position.x, ball.position.z, targetX, targetZ, "serve", ball.velocity). Step 4: At line 249-253, same pattern for rally hits.',
    estimated_effort: '20m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '88-110,184-188,249-253',
    status: 'pending',
    confidence_score: 0.97,
    metadata: JSON.stringify({parent_step:'L1-1'}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L2',
    sequence_number: 3,
    title: 'L2: gameStore.ts - In-place position mutation',
    description: 'Exact implementation for L1-2. Replace two ball.position = {...} with field mutations.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'L2 detail of L1-2',
    exact_instructions: 'Line 135: Replace "game.ballState.position = { x: serverPos.x, y: 1.0, z: serverPos.z };" with "game.ballState.position.x = serverPos.x; game.ballState.position.y = 1.0; game.ballState.position.z = serverPos.z;". Line 161: Replace "ball.position = { x: serverPos.x, y: 1.0, z: serverPos.z };" with "ball.position.x = serverPos.x; ball.position.y = 1.0; ball.position.z = serverPos.z;".',
    estimated_effort: '5m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '135,161',
    status: 'pending',
    confidence_score: 0.99,
    metadata: JSON.stringify({parent_step:'L1-2'}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L2',
    sequence_number: 4,
    title: 'L2: gameStore.ts - Direct index lookup replacing players.find()',
    description: 'Exact implementation for L1-3. Replace .find() with array index.',
    related_files: 'src/stores/gameStore.ts',
    rationale: 'L2 detail of L1-3',
    exact_instructions: 'Line 244-245: Replace "const targetTeam = player.team === \'A\' ? \'B\' : \'A\'; const targetPlayer = players.find(p => p.team === targetTeam) || players[0];" with "const targetIdx = player.team === \'A\' ? 2 : 0; const targetPlayer = players[targetIdx];"',
    estimated_effort: '5m',
    target_file: 'src/stores/gameStore.ts',
    target_lines: '244-245',
    status: 'pending',
    confidence_score: 0.99,
    metadata: JSON.stringify({parent_step:'L1-3'}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L2',
    sequence_number: 5,
    title: 'L2: performanceStore.ts - Pre-allocated scratch buffer + in-place sort',
    description: 'Exact implementation for L0-2. Add module-scope scratch buffer, insertion sort, loop counter.',
    related_files: 'src/stores/performanceStore.ts',
    rationale: 'L2 detail of L0-2',
    exact_instructions: 'Step 1: After line 4, add: const scratchBuffer = new Float64Array(RING_BUFFER_SIZE); Step 2: Add function float64InsertionSort(arr: Float64Array, len: number) { for(let i=1;i<len;i++){const key=arr[i];let j=i-1;while(j>=0&&arr[j]>key){arr[j+1]=arr[j];j--;}arr[j+1]=key;} }. Step 3: Replace lines 97-100 with: for(let i=0;i<count;i++){scratchBuffer[i]=frameTimeBuffer[i];}. Step 4: Replace line 103 with: float64InsertionSort(scratchBuffer, count);. Step 5: Replace lines 108-113 reading from times[] to read from scratchBuffer[]. Step 6: Replace line 114 with: let frameDrops=0; for(let i=0;i<count;i++){if(scratchBuffer[i]>33.33)frameDrops++;}',
    estimated_effort: '30m',
    target_file: 'src/stores/performanceStore.ts',
    target_lines: '4,97-114',
    status: 'pending',
    confidence_score: 0.98,
    metadata: JSON.stringify({parent_step:'L0-2'}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L2',
    sequence_number: 6,
    title: 'L2: simulationStore.ts - Direct court mutation with version counter',
    description: 'Exact implementation for L0-3. Add _courtVersion, mutate courts in place for all handlers in tick() and court-modifying methods.',
    related_files: 'src/stores/simulationStore.ts',
    rationale: 'L2 detail of L0-3',
    exact_instructions: 'Step 1: Add _courtVersion: number to SimulationStore interface. Step 2: Initialize _courtVersion: 0. Step 3: In tick() booking start handler (lines 137-148): Replace with: const court = get().courts.get(booking.courtId); if(court){court.status="IN_USE";court.activeBookingId=booking.id;set(s=>({_courtVersion:s._courtVersion+1}));} Step 4: Same pattern for booking end handler (lines 160-173). Step 5: Apply to setCourtStatus, updateCourtCleanliness, setCourtOutOfService, forceClean, forceEndSession.',
    estimated_effort: '45m',
    target_file: 'src/stores/simulationStore.ts',
    target_lines: '137-148,160-173,203-211,214-223,225-237,352-367,376-386',
    status: 'pending',
    confidence_score: 0.90,
    metadata: JSON.stringify({parent_step:'L0-3'}),
  },
  {
    iteration_id: ITER_ID,
    resolution: 'L2',
    sequence_number: 7,
    title: 'L2: useRobotController.ts - Lazy init + direct mutation for robot states',
    description: 'Exact implementation for L1-7 and L1-8. Initialize once, mutate directly.',
    related_files: 'src/hooks/useRobotController.ts',
    rationale: 'L2 detail of L1-7 and L1-8',
    exact_instructions: 'Step 1: Line 100-104: Replace with: let state = robotStates.current.get(robot.id); if(!state){state={currentPath:[],cleaningPath:[],rotation:0};robotStates.current.set(robot.id,state);} Step 2: Lines 113-117: Replace robotStates.current.set(robot.id,{...state,...}) with: state.currentPath=[]; state.cleaningPath=cleaningPath; Step 3: Lines 126-130: Replace with: state.currentPath=result.remainingPath; state.rotation=result.rotation; Step 4: Lines 182-186: Replace with: state.cleaningPath=result.remainingPath; state.rotation=result.rotation;',
    estimated_effort: '15m',
    target_file: 'src/hooks/useRobotController.ts',
    target_lines: '100-104,113-117,126-130,182-186',
    status: 'pending',
    confidence_score: 0.95,
    metadata: JSON.stringify({parent_steps:['L1-7','L1-8']}),
  },
];

const insert = db.transaction((stepsArr) => {
  const ids = [];
  for (const data of stepsArr) {
    const cols = Object.keys(data);
    const stmt = db.prepare(
      `INSERT INTO plan_steps (${cols.join(',')}) VALUES (${cols.map(() => '?').join(',')})`
    );
    const result = stmt.run(...cols.map(c => data[c]));
    ids.push(result.lastInsertRowid);
  }
  return ids;
});

const ids = insert(steps);
console.log(JSON.stringify({ step_ids: ids }));

db.close();
