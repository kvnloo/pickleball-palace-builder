[
  {
    "iteration_id": 14,
    "parent_step_id": 190,
    "resolution": "L2",
    "sequence_number": 1,
    "title": "Add buffer swap constants to sharedBufferLayout.ts",
    "description": "Add SIGNAL_READY and SIGNAL_STEP constants for Atomics-based signaling between main thread and worker.",
    "target_file": "src/workers/sharedBufferLayout.ts",
    "exact_instructions": "Append signal constants: SIGNAL_IDLE=0, SIGNAL_STEP_REQUESTED=1, SIGNAL_STEP_COMPLETE=2. These are stored at signalView[HEADER_SIGNAL_OFFSET] to coordinate step requests and completion.",
    "code_snippet": "export const SIGNAL_IDLE = 0;\nexport const SIGNAL_STEP_REQUESTED = 1;\nexport const SIGNAL_STEP_COMPLETE = 2;",
    "confidence_score": 9.7,
    "status": "pending"
  },
  {
    "iteration_id": 14,
    "parent_step_id": 190,
    "resolution": "L2",
    "sequence_number": 2,
    "title": "Implement atomic swap in worker handleStep",
    "description": "In computeWorker.ts handleStep(), after writing all entity data to the back buffer, atomically swap the buffer index and notify the main thread.",
    "target_file": "src/workers/computeWorker.ts",
    "exact_instructions": "At end of handleStep(): Atomics.store(signalView, HEADER_BUFFER_INDEX_OFFSET, newIndex) then Atomics.store(signalView, HEADER_SIGNAL_OFFSET, SIGNAL_STEP_COMPLETE) then Atomics.notify(signalView, HEADER_SIGNAL_OFFSET).",
    "code_snippet": "// After all computation:\nconst newIndex = 1 - currentIndex;\nAtomics.store(signalView, HEADER_BUFFER_INDEX_OFFSET, newIndex);\nAtomics.store(signalView, HEADER_SIGNAL_OFFSET, SIGNAL_STEP_COMPLETE);\nAtomics.notify(signalView, HEADER_SIGNAL_OFFSET, 1);",
    "confidence_score": 9.5,
    "status": "pending"
  },
  {
    "iteration_id": 14,
    "parent_step_id": 190,
    "resolution": "L2",
    "sequence_number": 3,
    "title": "Implement main-thread read with buffer index check",
    "description": "In computeBridge.ts WorkerBridge.getFrontBuffer(), use Atomics.load to safely read the current buffer index and select the correct front buffer for reading.",
    "target_file": "src/workers/computeBridge.ts",
    "exact_instructions": "WorkerBridge.getFrontBuffer() reads buffer index via Atomics.load(signalView, HEADER_BUFFER_INDEX_OFFSET). The front buffer is the one the worker is NOT currently writing to: if index is 0, front is dataViewA; if 1, front is dataViewB.",
    "code_snippet": "private getFrontBuffer(): Float32Array {\n  const idx = Atomics.load(this.views.signalView, HEADER_BUFFER_INDEX_OFFSET);\n  // Worker just wrote to the NEW index, so that is now the front (readable)\n  return idx === 0 ? this.views.dataViewA : this.views.dataViewB;\n}",
    "confidence_score": 9.4,
    "status": "pending"
  },
  {
    "iteration_id": 14,
    "parent_step_id": 191,
    "resolution": "L2",
    "sequence_number": 1,
    "title": "Create useComputeWorker.ts hook",
    "description": "Create the React hook that initializes the ComputeBridge on mount, provides step/read methods, and handles cleanup.",
    "target_file": "src/hooks/useComputeWorker.ts",
    "exact_instructions": "Create src/hooks/useComputeWorker.ts. Use useRef to hold ComputeBridge instance. useEffect to init on mount with court/robot counts, destroy on unmount. Return object with step(delta), readBallState(i), readPlayerState(i,j), readRobotState(i), readGameState(i), isReady boolean, isWorkerMode boolean.",
    "code_snippet": "import { useRef, useEffect, useState, useCallback } from 'react';\nimport { createComputeBridge, IComputeBridge } from '@/workers/computeBridge';\n\nexport function useComputeWorker(courtCount: number, robotCount: number) {\n  const bridgeRef = useRef<IComputeBridge | null>(null);\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    const bridge = createComputeBridge();\n    bridgeRef.current = bridge;\n    bridge.init(courtCount, robotCount).then(() => setIsReady(true));\n    return () => { bridge.destroy(); bridgeRef.current = null; setIsReady(false); };\n  }, [courtCount, robotCount]);\n\n  const step = useCallback((dt: number) => bridgeRef.current?.step(dt), []);\n\n  return { step, bridge: bridgeRef, isReady, isWorkerMode: bridgeRef.current?.isWorkerMode() ?? false };\n}",
    "confidence_score": 9.0,
    "status": "pending"
  },
  {
    "iteration_id": 14,
    "parent_step_id": 191,
    "resolution": "L2",
    "sequence_number": 2,
    "title": "Integrate useComputeWorker into game rendering components",
    "description": "In the component that renders courts/games, use the compute bridge to read positions from SAB instead of from Zustand game state.",
    "target_file": "src/hooks/useSimulation.ts",
    "exact_instructions": "Modify or create a new wrapper that uses useComputeWorker alongside existing useSimulation. In useFrame, call bridge.step(delta) to trigger worker computation, then read ball/player positions from bridge to update mesh refs. This replaces the direct gameStore.updateGame() calls.",
    "code_snippet": "// In the game rendering component:\nuseFrame((_, delta) => {\n  if (!isPlaying || !bridge.current) return;\n  // Trigger worker step\n  bridge.current.step(delta);\n  // Read results - these come from SAB front buffer\n  for (let c = 0; c < courtCount; c++) {\n    const ball = bridge.current.readBallState(c);\n    // Update Three.js mesh directly via ref\n    ballMeshRefs[c].current.position.set(ball.px, ball.py, ball.pz);\n  }\n});",
    "confidence_score": 8.7,
    "status": "pending"
  },
  {
    "iteration_id": 14,
    "parent_step_id": 192,
    "resolution": "L2",
    "sequence_number": 1,
    "title": "Create FallbackBridge class",
    "description": "Create a FallbackBridge that implements IComputeBridge but runs all compute synchronously on the main thread using regular ArrayBuffer.",
    "target_file": "src/workers/fallbackBridge.ts",
    "exact_instructions": "Create src/workers/fallbackBridge.ts. Export class FallbackBridge implements IComputeBridge. Uses regular ArrayBuffer (not SharedArrayBuffer) and Float32Array views. init() allocates buffer and fills with initial state. step() runs physicsEngine.stepBallPhysics(), aiEngine.stepPlayerMovement(), pathfindingEngine.stepRobotNavigation() synchronously. Read methods return data from the single buffer. isWorkerMode() returns false.",
    "code_snippet": "import { IComputeBridge, BallReadout, PlayerReadout, RobotReadout, GameReadout } from './computeBridge';\nimport { COURT_FLOATS, ROBOT_FLOATS, getBallOffset, getPlayerOffset, getRobotOffset } from './sharedBufferLayout';\nimport { stepBallPhysics } from './physicsEngine';\nimport { stepPlayerMovement } from './aiEngine';\n\nexport class FallbackBridge implements IComputeBridge {\n  private data: Float32Array | null = null;\n  private courtCount = 0;\n  private robotCount = 0;\n\n  async init(courtCount: number, robotCount: number): Promise<void> {\n    this.courtCount = courtCount;\n    this.robotCount = robotCount;\n    const size = courtCount * COURT_FLOATS + robotCount * ROBOT_FLOATS;\n    this.data = new Float32Array(size);\n  }\n\n  step(deltaTime: number): void {\n    if (!this.data) return;\n    for (let c = 0; c < this.courtCount; c++) {\n      stepBallPhysics(this.data, getBallOffset(c), deltaTime, 0);\n      for (let p = 0; p < 4; p++) {\n        stepPlayerMovement(this.data, getPlayerOffset(c, p), deltaTime);\n      }\n    }\n  }\n\n  readBallState(courtIndex: number): BallReadout {\n    const o = getBallOffset(courtIndex);\n    const d = this.data!;\n    return { px:d[o],py:d[o+1],pz:d[o+2],vx:d[o+3],vy:d[o+4],vz:d[o+5],visible:d[o+6] };\n  }\n\n  isWorkerMode(): boolean { return false; }\n  destroy(): void { this.data = null; }\n}",
    "confidence_score": 9.3,
    "status": "pending"
  },
  {
    "iteration_id": 14,
    "parent_step_id": 192,
    "resolution": "L2",
    "sequence_number": 2,
    "title": "Add feature detection logging to computeBridge factory",
    "description": "Add console.info logging to createComputeBridge() to report which mode was selected and why, helping developers debug COOP/COEP issues.",
    "target_file": "src/workers/computeBridge.ts",
    "exact_instructions": "In createComputeBridge(), before returning, log: console.info('[ComputeBridge] Mode:', mode, 'SharedArrayBuffer:', available, 'crossOriginIsolated:', crossOriginIsolated).",
    "code_snippet": "export function createComputeBridge(): IComputeBridge {\n  const sabAvailable = typeof SharedArrayBuffer !== 'undefined';\n  const atomicsAvailable = typeof Atomics !== 'undefined';\n  const coiEnabled = typeof crossOriginIsolated !== 'undefined' ? crossOriginIsolated : false;\n  const useWorker = sabAvailable && atomicsAvailable && coiEnabled;\n\n  console.info(\n    '[ComputeBridge]',\n    useWorker ? 'Worker mode' : 'Fallback mode',\n    '| SAB:', sabAvailable,\n    '| Atomics:', atomicsAvailable,\n    '| COI:', coiEnabled\n  );\n\n  return useWorker ? new WorkerBridge() : new FallbackBridge();\n}",
    "confidence_score": 9.6,
    "status": "pending"
  }
]
